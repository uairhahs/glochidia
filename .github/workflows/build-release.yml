name: Build and Release Static Binaries
# trunk-ignore-all(yamllint/quoted-strings)

on:
  workflow_dispatch:
    inputs:
      release_tag:
        description: "Release tag (e.g., latest, v1.0.0)"
        required: true
        default: "latest"
  push:
    branches:
      - master
    tags:
      - "v*"

env:
  REPO_VERSION: "1.0.0"
  CARGO_TERM_COLOR: always

jobs:
  build-rust:
    name: Build Rust Tools
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        tool:
          - name: gpm
            description: "Glochidia Package Manager"
            license: "GPL-2.0-or-later"
            source_url: "https://github.com/${{ github.repository }}"
            working_dir: gpm
          - name: starship
            description: "Cross-shell prompt"
            license: "ISC"
            source_url: "https://github.com/starship/starship"
            repo_url: "https://github.com/starship/starship"
            build_cmd: "cargo build --release --no-default-features --features battery"
          - name: msedit
            description: "Text editor for terminals"
            license: "MIT"
            source_url: "https://github.com/microsoft/edit"
            repo_url: "https://github.com/microsoft/edit"
            binary_name: "edit"
            build_cmd: "cargo build --all-features --release"
          - name: set_locale
            description: "Locale management utilities (set_locale, locale-gen)"
            license: "GPL-2.0-or-later"
            source_url: "https://github.com/${{ github.repository }}"
            working_dir: glochidia-locale
            binary_name: "set_locale"

    container:
      image: rust:alpine
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install GNU tar for caching
        run: apk add --no-cache tar

      - name: Fetch latest release version
        id: fetch-version
        run: |
          if [ -n "${{ matrix.tool.repo_url }}" ]; then
            echo "Fetching latest release for ${{ matrix.tool.name }}..."
            LATEST_TAG=$(wget -qO- "https://api.github.com/repos/$(echo ${{ matrix.tool.repo_url }} | sed 's|https://github.com/||')/releases/latest" | grep '"tag_name":' | sed -E 's/.*"tag_name": "([^"]+)".*/\1/')
            if [ -z "$LATEST_TAG" ]; then
              echo "Failed to fetch latest release, using configured version"
              LATEST_TAG="${{ matrix.tool.git_ref || matrix.tool.version }}"
            fi
            echo "version=$LATEST_TAG" >> $GITHUB_OUTPUT
            echo "Latest version: $LATEST_TAG"
          else
            echo "version=${{ matrix.tool.version }}" >> $GITHUB_OUTPUT
            echo "Using configured version: ${{ matrix.tool.version }}"
          fi

      - name: Cache compiled binary
        id: cache-binary
        uses: actions/cache@v4
        with:
          path: ${{ matrix.tool.name }}-bin
          key: ${{ runner.os }}-binary-${{ matrix.tool.name }}-${{ steps.fetch-version.outputs.version }}-musl

      - name: Install build dependencies
        run: apk add --no-cache git musl-dev file cmake make gcc g++ linux-headers

      - name: Cache cargo registry
        if: steps.cache-binary.outputs.cache-hit != 'true'
        uses: actions/cache@v4
        with:
          path: ~/.cargo/registry
          key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}

      - name: Cache cargo index
        if: steps.cache-binary.outputs.cache-hit != 'true'
        uses: actions/cache@v4
        with:
          path: ~/.cargo/git
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}

      - name: Build ${{ matrix.tool.name }}
        if: steps.cache-binary.outputs.cache-hit != 'true'
        run: |
          echo "Building ${{ matrix.tool.name }}..."
          if [ -n "${{ matrix.tool.working_dir }}" ]; then
            cd ${{ matrix.tool.working_dir }}
            cargo build --release --target x86_64-unknown-linux-musl
            strip target/x86_64-unknown-linux-musl/release/${{ matrix.tool.name }}
            cp target/x86_64-unknown-linux-musl/release/${{ matrix.tool.name }} ../${{ matrix.tool.name }}-bin

            # Extract version from built binary with multiple fallback patterns
            VERSION_OUTPUT=$(target/x86_64-unknown-linux-musl/release/${{ matrix.tool.name }} --version 2>&1 || echo "")

            # Try strict X.Y.Z pattern first
            VERSION=$(echo "$VERSION_OUTPUT" | sed -n 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p' | head -n1)

            # If no match, try looser pattern (any number sequence with dots)
            if [ -z "$VERSION" ]; then
              VERSION=$(echo "$VERSION_OUTPUT" | grep -o -E "([0-9]+\.?)+[0-9]+" | head -1)
            fi

            # Remove 'v' prefix if present
            VERSION=$(echo "$VERSION" | sed 's/^v//')

            # Use repo version as final fallback
            echo "${VERSION:-${{ env.REPO_VERSION }}}" > ../${{ matrix.tool.name }}.version
            echo "Version extracted for ${{ matrix.tool.name }}: ${VERSION:-${{ env.REPO_VERSION }}}"
          elif [ -n "${{ matrix.tool.repo_url }}" ]; then
            # Build external repos
            BUILD_DIR="/tmp/build_${{ matrix.tool.name }}"
            git clone --depth 1 --branch ${{ steps.fetch-version.outputs.version }} ${{ matrix.tool.repo_url }} ${BUILD_DIR}
            cd ${BUILD_DIR}
            eval "${{ matrix.tool.build_cmd }}"
            # Find and copy binary back to workspace
            BINARY_NAME="${{ matrix.tool.binary_name || matrix.tool.name }}"
            if [ -f "target/x86_64-unknown-linux-musl/release/${BINARY_NAME}" ]; then
              strip target/x86_64-unknown-linux-musl/release/${BINARY_NAME}

              # Extract version from built binary with multiple fallback patterns
              VERSION_OUTPUT=$(target/x86_64-unknown-linux-musl/release/${BINARY_NAME} --version 2>&1 || echo "")

              # Try strict X.Y.Z pattern first
              VERSION=$(echo "$VERSION_OUTPUT" | sed -n 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p' | head -n1)

              # If no match, try looser pattern (any number sequence with dots)
              if [ -z "$VERSION" ]; then
                VERSION=$(echo "$VERSION_OUTPUT" | grep -o -E "([0-9]+\.?)+[0-9]+" | head -1)
              fi

              # Remove 'v' prefix if present
              VERSION=$(echo "$VERSION" | sed 's/^v//')

              # Use fetched version as fallback, then repo version
              echo "${VERSION:-${{ steps.fetch-version.outputs.version }}-${{ env.REPO_VERSION }}}" > "${{ matrix.tool.name }}.version"
              echo "Version extracted for ${{ matrix.tool.name }}: ${VERSION:-${{ steps.fetch-version.outputs.version }}}"
              cp target/x86_64-unknown-linux-musl/release/${BINARY_NAME} "${{ matrix.tool.name }}-bin"
            else
              echo "Error: Binary not found at expected path"
              exit 1
            fi
          fi

      - name: Verify static binary
        if: steps.cache-binary.outputs.cache-hit != 'true'
        run: |
          echo "Verifying ${{ matrix.tool.name }} is statically linked..."
          file ${{ matrix.tool.name }}-bin
          if file ${{ matrix.tool.name }}-bin | grep -q "dynamically linked"; then
            if file ${{ matrix.tool.name }}-bin | grep -q "interpreter"; then
              echo "Error: Binary is dynamically linked with interpreter"
              exit 1
            fi
          fi
          echo "Binary verification passed"

      - name: Finalize version metadata
        run: |
          VERSION_FILE="${{ matrix.tool.name }}.version"

          # Ensure version file exists and is not empty
          if [ ! -f "$VERSION_FILE" ]; then
            # File doesn't exist, create with fallback
            if [ -n "${{ matrix.tool.working_dir }}" ]; then
              echo "${{ env.REPO_VERSION }}" > "$VERSION_FILE"
              echo "Created version file for ${{ matrix.tool.name }} with repo version: ${{ env.REPO_VERSION }}"
            else
              echo "${{ steps.fetch-version.outputs.version }}" > "$VERSION_FILE"
              echo "Created version file for ${{ matrix.tool.name }} with fetched version: ${{ steps.fetch-version.outputs.version }}"
            fi
          else
            # File exists, clean it up and validate
            VERSION=$(cat "$VERSION_FILE" | tr -d '\n\r' | xargs | sed 's/^v//')

            if [ -z "$VERSION" ] || [ "$VERSION" = "unknown" ]; then
              # Empty or unknown, use fallback
              if [ -n "${{ matrix.tool.working_dir }}" ]; then
                echo "${{ env.REPO_VERSION }}" > "$VERSION_FILE"
                echo "Version file was empty, using repo version for ${{ matrix.tool.name }}: ${{ env.REPO_VERSION }}"
              else
                echo "${{ steps.fetch-version.outputs.version }}" > "$VERSION_FILE"
                echo "Version file was empty, using fetched version for ${{ matrix.tool.name }}: ${{ steps.fetch-version.outputs.version }}"
              fi
            else
              # Valid version, write it back (cleaned)
              echo "$VERSION" > "$VERSION_FILE"
              echo "Version for ${{ matrix.tool.name }}: $VERSION"
            fi
          fi

      - name: Upload artifact with metadata
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.tool.name }}
          path: |
            ${{ matrix.tool.name }}-bin
            ${{ matrix.tool.name }}.version

  build-c-tools:
    name: Build C/C++ Tools
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        tool:
          - name: make
            description: "GNU Make build tool"
            license: "GPL-3.0-or-later"
            source_url: "https://ftp.gnu.org/gnu/make/make-4.4.1.tar.gz"
            source_sha256: "dd16fb1d67bfab79a72f5e8390735c49e3e8e70b4945a15ab1f81ddb78658fb3"
            build_cmd: "./configure LDFLAGS=-static && make -j$(nproc)"
          - name: gawk
            description: "GNU Awk text processing"
            license: "GPL-3.0-or-later"
            source_url: "https://ftp.gnu.org/gnu/gawk/gawk-5.3.2.tar.xz"
            source_sha256: "3203e52edb182061ac4fe37f0040e8d5b5ed5d37e1c8a1dcf5d8288d0c757cd5"
            build_cmd: "./configure LDFLAGS=-static && make -j$(nproc)"
          - name: ble.sh
            description: "Bash Line Editor"
            license: "BSD-3-Clause"
            source_url: "https://github.com/akinomyoga/ble.sh"
            build_cmd: "make"
            version: "0.4.0"
          - name: fastfetch
            description: "System information tool"
            license: "MIT"
            source_url: "https://github.com/fastfetch-cli/fastfetch"
            build_cmd: "cmake -B build -DCMAKE_BUILD_TYPE=Release -DCMAKE_EXE_LINKER_FLAGS=-static -DENABLE_SYSTEM_YYJSON=OFF -DENABLE_DIRECTWRITE=OFF -DENABLE_XRANDR=OFF -DENABLE_X11=OFF -DENABLE_WAYLAND=OFF -DENABLE_GIO=OFF -DENABLE_DCONF=OFF -DENABLE_DBUS=OFF -DENABLE_XFCONF=OFF -DENABLE_SQLITE3=OFF -DENABLE_IMAGEMAGICK=OFF -DENABLE_CHAFA=OFF -DENABLE_ZLIB=OFF -DENABLE_EGL=OFF -DENABLE_GLX=OFF -DENABLE_OSMESA=OFF -DENABLE_OPENCL=OFF -DENABLE_VULKAN=OFF -DENABLE_RPM=OFF -DENABLE_DRM=OFF -DENABLE_FREETYPE=OFF && cmake --build build --target fastfetch"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Fetch latest release version
        id: fetch-version
        run: |
          if [[ "${{ matrix.tool.source_url }}" == *"github.com"* ]] && [ -n "${{ matrix.tool.git_ref }}" ]; then
            echo "Fetching latest release for ${{ matrix.tool.name }}..."
            REPO_PATH=$(echo "${{ matrix.tool.source_url }}" | sed 's|https://github.com/||' | sed 's|\.git$||')
            LATEST_TAG=$(curl -s "https://api.github.com/repos/${REPO_PATH}/releases/latest" | grep '"tag_name":' | sed -E 's/.*"tag_name": "([^"]+)".*/\1/')
            if [ -z "$LATEST_TAG" ]; then
              echo "Failed to fetch latest release, using configured version"
              LATEST_TAG="${{ matrix.tool.git_ref }}"
            fi
            echo "version=$LATEST_TAG" >> $GITHUB_OUTPUT
            echo "Latest version: $LATEST_TAG"
          else
            # Use explicitly configured version or default fallback
            CONFIGURED_VERSION="${{ matrix.tool.version }}"
            if [ -z "$CONFIGURED_VERSION" ]; then
              CONFIGURED_VERSION="unknown"
            fi
            echo "version=$CONFIGURED_VERSION" >> $GITHUB_OUTPUT
            echo "Using configured version: $CONFIGURED_VERSION"
          fi

      - name: Install podman
        run: |
          sudo apt-get update
          sudo apt-get install -y podman

      - name: Build ${{ matrix.tool.name }}
        run: |
          # Set up environment for grow_glochidium.sh
          export CONTAINER_RUNTIME=podman
          export DEPLOY_METHOD=ci-cd
          export DEPLOY_USER=ci
          export DEPLOY_HOST=localhost
          export DEPLOY_PATH=/tmp/ci

          # Run the build script and capture output to extract BUILD_DIR
          OUTPUT=$(bash grow_glochidium.sh \
            "${{ matrix.tool.source_url }}" \
            "${{ matrix.tool.name }}" \
            "${{ matrix.tool.build_cmd }}" 2>&1)

          echo "$OUTPUT"

          # Extract the actual BUILD_DIR from the script output
          BUILD_DIR=$(echo "$OUTPUT" | grep "Build directory preserved:" | sed 's/.*Build directory preserved: //')

          if [ -z "$BUILD_DIR" ]; then
            echo "Error: Could not determine BUILD_DIR from script output"
            exit 1
          fi

          echo "Detected BUILD_DIR: $BUILD_DIR"

          # Initialize version variable
          VERSION=""

          # Copy binary from build dir and extract version
          if [ -f "${BUILD_DIR}/${{ matrix.tool.name }}" ]; then
            cp "${BUILD_DIR}/${{ matrix.tool.name }}" ./${{ matrix.tool.name }}-bin
            chmod +x ./${{ matrix.tool.name }}-bin

            # Try to extract version from the binary
            VERSION_OUTPUT=$(./${{ matrix.tool.name }}-bin --version 2>&1 || echo "")

            # Try strict X.Y.Z pattern first
            VERSION=$(echo "$VERSION_OUTPUT" | sed -n 's/.*\([0-9]\+\.[0-9]\+\.[0-9]\+\).*/\1/p' | head -n1)

            # If no match, try looser pattern
            if [ -z "$VERSION" ]; then
              VERSION=$(echo "$VERSION_OUTPUT" | grep -o -E "([0-9]+\.?)+[0-9]+" | head -1)
            fi

            # Remove 'v' prefix if present
            VERSION=$(echo "$VERSION" | sed 's/^v//')

          elif [ -f "${BUILD_DIR}/${{ matrix.tool.name }}.sh" ]; then
            cp "${BUILD_DIR}/${{ matrix.tool.name }}.sh" ./${{ matrix.tool.name }}-bin
            chmod +x ./${{ matrix.tool.name }}-bin

            # For shell scripts, extract version from the script itself
            VERSION=$(grep -o -E "([0-9]+\.?)+[0-9]+" "${BUILD_DIR}/${{ matrix.tool.name }}.sh" | head -n1)

            # Remove 'v' prefix if present
            VERSION=$(echo "$VERSION" | sed 's/^v//')

          else
            echo "Error: Binary not found in ${BUILD_DIR}"
            ls -la "${BUILD_DIR}" || true
            exit 1
          fi

          # Ensure version file is created with appropriate fallback
          if [ -z "$VERSION" ]; then
            # No version extracted, use configured version or fetched version
            if [ -n "${{ matrix.tool.version }}" ]; then
              VERSION="${{ matrix.tool.version }}"
            else
              VERSION="${{ steps.fetch-version.outputs.version }}"
            fi
          fi

          # Clean version and write to file
          VERSION=$(echo "$VERSION" | tr -d '\n\r' | xargs | sed 's/^v//')
          echo "$VERSION" > ${{ matrix.tool.name }}.version
          echo "Version for ${{ matrix.tool.name }}: $VERSION"

      - name: Verify static binary
        run: |
          echo "Verifying ${{ matrix.tool.name }} is statically linked..."
          file ${{ matrix.tool.name }}-bin
          if file ${{ matrix.tool.name }}-bin | grep -q "dynamically linked"; then
            echo "Error: Binary is dynamically linked"
            exit 1
          fi
          if ! file ${{ matrix.tool.name }}-bin | grep -q "statically linked"; then
            echo "Warning: Cannot confirm static linking"
          fi
          echo "Binary verification passed"

      - name: Finalize version metadata
        run: |
          VERSION_FILE="${{ matrix.tool.name }}.version"

          # Ensure version file exists and is not empty
          if [ ! -f "$VERSION_FILE" ]; then
            # File doesn't exist, create with fallback
            if [ -n "${{ matrix.tool.version }}" ]; then
              echo "${{ matrix.tool.version }}" > "$VERSION_FILE"
              echo "Created version file for ${{ matrix.tool.name }} with configured version: ${{ matrix.tool.version }}"
            else
              echo "${{ steps.fetch-version.outputs.version }}" > "$VERSION_FILE"
              echo "Created version file for ${{ matrix.tool.name }} with fetched version: ${{ steps.fetch-version.outputs.version }}"
            fi
          else
            # File exists, clean it up and validate
            VERSION=$(cat "$VERSION_FILE" | tr -d '\n\r' | xargs | sed 's/^v//')

            if [ -z "$VERSION" ] || [ "$VERSION" = "unknown" ]; then
              # Empty or unknown, use fallback
              if [ -n "${{ matrix.tool.version }}" ]; then
                echo "${{ matrix.tool.version }}" > "$VERSION_FILE"
                echo "Version file was empty, using configured version for ${{ matrix.tool.name }}: ${{ matrix.tool.version }}"
              else
                echo "${{ steps.fetch-version.outputs.version }}" > "$VERSION_FILE"
                echo "Version file was empty, using fetched version for ${{ matrix.tool.name }}: ${{ steps.fetch-version.outputs.version }}"
              fi
            else
              # Valid version, write it back (cleaned)
              echo "$VERSION" > "$VERSION_FILE"
              echo "Version for ${{ matrix.tool.name }}: $VERSION"
            fi
          fi

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.tool.name }}
          path: |
            ${{ matrix.tool.name }}-bin
            ${{ matrix.tool.name }}.version

  generate-manifest:
    name: Generate Manifest and Create Release
    needs: [build-rust, build-c-tools]
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare binaries
        run: |
          mkdir -p release-files versions
          echo "Preparing binaries..."
          for dir in artifacts/*/; do
            tool=$(basename "$dir")
            if [ -f "$dir/${tool}-bin" ]; then
              mv "$dir/${tool}-bin" "release-files/${tool}"
              echo "  - $tool"
            fi
            if [ -f "$dir/${tool}.version" ]; then
              mv "$dir/${tool}.version" "versions/${tool}.version"
            fi
            # Handle glochidia-locale's additional binaries
            if [ -f "$dir/set_locale-bin" ]; then
              mv "$dir/set_locale-bin" "release-files/set_locale"
              echo "  - set_locale"
            fi
            if [ -f "$dir/set_locale.version" ]; then
              mv "$dir/set_locale.version" "versions/set_locale.version"
            fi
          done
          chmod +x release-files/*
          ls -lh release-files/
          echo "Versions collected:"
          ls -lh versions/ || true

      - name: Download GPL licenses
        run: |
          mkdir -p licenses
          if [ ! -f licenses/GPL-2.0.txt ]; then
            echo "Downloading GPL-2.0..."
            curl -sS https://www.gnu.org/licenses/old-licenses/gpl-2.0.txt -o licenses/GPL-2.0.txt
          fi
          if [ ! -f licenses/GPL-3.0.txt ]; then
            echo "Downloading GPL-3.0..."
            curl -sS https://www.gnu.org/licenses/gpl-3.0.txt -o licenses/GPL-3.0.txt
          fi

      - name: Build ZimaOS RAW package
        run: |
          sudo apt-get update && sudo apt-get install -y squashfs-tools
          bash zpkg/build-zpkg.sh
          cp gpm.raw release-files/
          echo "Added gpm.raw to release files"

      - name: Copy compliance files
        run: |
          cp SOURCES.txt release-files/
          cp COPYING release-files/
          cp -r licenses release-files/

      - name: Generate manifest with Python
        run: |
          python3 << 'PYEOF'
          import json
          import hashlib
          import os
          from datetime import datetime

          RELEASE_TAG = "${{ github.event.inputs.release_tag || 'latest' }}"
          REPO = "${{ github.repository }}"

          # Read versions from version files with robust fallback logic
          def read_version(tool_name):
              version_file = f"versions/{tool_name}.version"
              if os.path.exists(version_file):
                  with open(version_file, 'r') as f:
                      version = f.read().strip()
                      # Remove 'v' prefix if present
                      version = version.lstrip('v')
                      if version and version != "unknown" and version != "":
                          return version
              # Explicit fallbacks per tool
              fallback_versions = {
                  "gpm": "${{ env.REPO_VERSION }}",
                  "set_locale": "${{ env.REPO_VERSION }}",
                  "ble.sh": "0.4.0",
              }
              return fallback_versions.get(tool_name, "unknown")

          tools_metadata = {
              "gpm": {
                  "description": "Glochidia Package Manager",
                  "license": "GPL-2.0-or-later",
                  "source_url": f"https://github.com/{REPO}",
                  "build_type": "rust-alpine"
              },
              "make": {
                  "description": "GNU Make build tool",
                  "license": "GPL-3.0-or-later",
                  "source_url": "https://ftp.gnu.org/gnu/make/make-4.4.1.tar.gz",
                  "source_sha256": "dd16fb1d67bfab79a72f5e8390735c49e3e8e70b4945a15ab1f81ddb78658fb3",
                  "build_type": "alpine"
              },
              "gawk": {
                  "description": "GNU Awk text processing",
                  "license": "GPL-3.0-or-later",
                  "source_url": "https://ftp.gnu.org/gnu/gawk/gawk-5.3.2.tar.xz",
                  "source_sha256": "3203e52edb182061ac4fe37f0040e8d5b5ed5d37e1c8a1dcf5d8288d0c757cd5",
                  "build_type": "alpine"
              },
              "starship": {
                  "description": "Cross-shell prompt",
                  "license": "ISC",
                  "source_url": "https://github.com/starship/starship",
                  "build_type": "rust-alpine"
              },
              "fastfetch": {
                  "description": "System information tool",
                  "license": "MIT",
                  "source_url": "https://github.com/fastfetch-cli/fastfetch",
                  "build_type": "alpine"
              },
              "ble.sh": {
                  "description": "Bash Line Editor",
                  "license": "BSD-3-Clause",
                  "source_url": "https://github.com/akinomyoga/ble.sh",
                  "build_type": "script"
              },
              "msedit": {
                  "description": "Text editor for terminals",
                  "license": "MIT",
                  "source_url": "https://github.com/microsoft/edit",
                  "build_type": "rust-alpine"
              },
              "set_locale": {
                  "description": "Locale setting utility",
                  "license": "GPL-2.0-or-later",
                  "source_url": f"https://github.com/{REPO}",
                  "build_type": "rust-alpine"
              }
          }

          manifest = {
              "repo_version": "${{ env.REPO_VERSION }}",
              "updated_at": datetime.utcnow().strftime("%Y-%m-%dT%H:%M:%SZ"),
              "tools": {}
          }


            for tool_name in os.listdir("release-files"):
              if tool_name.startswith("."):
                continue

              filepath = f"release-files/{tool_name}"
              if not os.path.isfile(filepath):
                continue

              with open(filepath, "rb") as f:
                data = f.read()
                sha256 = hashlib.sha256(data).hexdigest()
                size = len(data)

              if tool_name not in tools_metadata:
                print(f"Warning: No metadata for {tool_name}")
                continue

              metadata = tools_metadata[tool_name]
              tool_version = read_version(tool_name)

              tool_entry = {
                "version": tool_version,
                "description": metadata["description"],
                "url": f"https://github.com/{REPO}/releases/download/{RELEASE_TAG}/{tool_name}",
                "sha256": sha256,
                "size": size,
                "build_type": metadata["build_type"],
                "license": metadata["license"],
                "source_url": metadata["source_url"]
              }

              if "source_sha256" in metadata:
                tool_entry["source_sha256"] = metadata["source_sha256"]

              manifest["tools"][tool_name] = tool_entry
              print(f"Added {tool_name}: {size} bytes, SHA256: {sha256[:16]}..., Version: {tool_version}")

          with open("release-files/manifest.json", "w") as f:
              json.dump(manifest, f, indent=2)

          print("\nGenerated manifest:")
          print(json.dumps(manifest, indent=2))
          PYEOF

          echo ""
          echo "Final release files:"
          ls -lh release-files/
          echo ""
          echo "Manifest SHA256 checksums:"
          grep '"sha256"' release-files/manifest.json

      - name: Generate release body
        run: |
          REPO="${{ github.repository }}"
          RELEASE_TAG="${{ github.event.inputs.release_tag || 'latest' }}"
          BUILD_INFO="${{ github.event_name == 'workflow_dispatch' && 'manually' || 'from tag push' }}"
          COMMIT="${{ github.sha }}"

          python3 << PYEOF
          import json

          with open('release-files/manifest.json', 'r') as f:
              manifest = json.load(f)

          with open('release-body.md', 'w') as f:
              f.write("## Static Binaries for ZimaOS\n\n")
              f.write("Built from source with GPL compliance. All binaries are statically linked and verified.\n\n")
              f.write("### Available Tools\n")

              for tool_name in sorted(manifest['tools'].keys()):
                  tool = manifest['tools'][tool_name]
                  # Strip leading 'v' from version if present to avoid 'vv' prefix
                  version = tool['version'].lstrip('v') if tool['version'] else 'unknown'
                  f.write(f"- **{tool_name}** v{version} - {tool['description']}\n")

              f.write("\n### Installation\n")
              f.write("```bash\n")
              f.write("# Download and install gpm\n")
              f.write(f"wget https://github.com/${REPO}/releases/download/${RELEASE_TAG}/gpm\n")
              f.write("chmod +x gpm\n")
              f.write("mv gpm /DATA/bin/\n\n")
              f.write("# Configure PATH and install tools\n")
              f.write("gpm setup-path\n")
              f.write("source ~/.bashrc\n")
              f.write("gpm install make\n")
              f.write("gpm install gawk\n")
              f.write("gpm list\n")
              f.write("```\n\n")
              f.write("### Verification\n")
              f.write("- `manifest.json` - SHA256 checksums for all binaries\n")
              f.write("- `SOURCES.txt` - Source code provenance\n")
              f.write("- `COPYING` - GPL compliance notice\n")
              f.write("- `licenses/` - Full license texts\n\n")
              f.write("### Build Information\n")
              f.write(f"- Built: ${BUILD_INFO}\n")
              f.write(f"- Commit: ${COMMIT}\n")
              f.write("- All binaries verified as statically linked\n")

          print("Generated release body with tool versions")
          PYEOF

          cat release-body.md

      - name: Determine release version
        id: release-version
        run: |
          if [ -n "${{ github.event.inputs.release_tag }}" ]; then
            # Use explicitly provided tag from workflow dispatch
            VERSION="${{ github.event.inputs.release_tag }}"
          elif [[ "${{ github.ref }}" == refs/tags/* ]]; then
            # Use tag from push event (e.g., v1.0.0)
            VERSION="${GITHUB_REF#refs/tags/}"
          else
            # Push to master branch always uses "latest"
            VERSION="latest"
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Release version: $VERSION"

      - name: Create/Update Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.release-version.outputs.version }}
          name: Release ${{ steps.release-version.outputs.version }}
          body_path: release-body.md
          files: |
            release-files/*
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
